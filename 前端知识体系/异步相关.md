# `Generator` 函数的概念和应用

##  1. 简介

## 基本概念

1. **从语法**上看 `Generator` 函数可以看成是一个状态机，内部封装了多个状态。

2. **从执行机制**上看，`Generator` 函数会返回一个遍历器对象，可以依次遍历函数内部的每一个状态。

3. **从代码形式**上看，`Generator` 函数就是一个普通函数，但是有两个特征。

   1. `function` 关键字和函数名之间有一个 `*` 号。
   2. 函数体内部使用 `yield` 表达式。

   ```javascript
   function* helloWorldGenerator() {
     yield 'hello';
     yield 'world';
     return 'ending';
   }
   
   var hw = helloWorldGenerator();
   ```

   上面代码定义了一个 Generator 函数`helloWorldGenerator`，它内部有两个`yield`表达式（`hello`和`world`），即该函数有三个状态：`hello，world` 和 `return` 语句（结束执行）。

4. **从调用方式**看，Generator函数的调用方式和普通函数一样，但是调用Generator函数之后，***函数并不执行***，而是返回一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）。

5. 调用 `Generator` 函数拿到遍历器对象之后，下一步就是调用遍历器对象的 `next` 方法，使得指针移向下一个状态。也就是说，每次调用`next`方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个`yield`表达式（或`return`语句）为止。换言之，Generator 函数是分段执行的，`yield`表达式是暂停执行的标记，而`next`方法可以恢复执行。

## `yield` 表达式

> 由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。
> 1. `yield` 表达式只能用在 `Generator` 函数内部，用在普通函数内部会报错。
>
> 2. `yield`表达式如果用在另一个表达式之中，必须放在圆括号里面。
>
>    ```js
>    function* demo() {
>      console.log('Hello' + yield); // SyntaxError
>      console.log('Hello' + yield 123); // SyntaxError
>    
>      console.log('Hello' + (yield)); // OK
>      console.log('Hello' + (yield 123)); // OK
>    }
>    ```
>
> 3. 

## `next` 方法的参数

`yield`表达式本身没有返回值，或者说总是返回`undefined`。`next`方法可以带一个参数，***该参数就会被当作上一个`yield`表达式的返回值。***

看一个例子：

```javascript
function* foo(x) {
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
}

var a = foo(5);
a.next() // Object{value:6, done:false}
a.next() // Object{value:NaN, done:false}
a.next() // Object{value:NaN, done:true}

var b = foo(5);
b.next() // { value:6, done:false }
b.next(12) // { value:8, done:false }
b.next(13) // { value:42, done:true }
```

上面代码中，第二次运行`next`方法的时候不带参数，导致 y 的值等于`2 * undefined`（即`NaN`），除以 3 以后还是`NaN`，因此返回对象的`value`属性也等于`NaN`。第三次运行`Next`方法的时候不带参数，所以`z`等于`undefined`，返回对象的`value`属性等于`5 + NaN + undefined`，即`NaN`。

如果向`next`方法提供参数，返回结果就完全不一样了。上面代码第一次调用`b`的`next`方法时，返回`x+1`的值`6`；第二次调用`next`方法，将上一次`yield`表达式的值设为`12`，因此`y`等于`24`，返回`y / 3`的值`8`；第三次调用`next`方法，将上一次`yield`表达式的值设为`13`，因此`z`等于`13`，这时`x`等于`5`，`y`等于`24`，所以`return`语句的值等于`42`。

注意，由于`next`方法的参数表示上一个`yield`表达式的返回值，所以在第一次使用`next`方法时，传递参数是无效的。V8 引擎直接忽略第一次使用`next`方法时的参数，只有从第二次使用`next`方法开始，参数才是有效的。从语义上讲，第一个`next`方法用来启动遍历器对象，所以不用带有参数。

## for...of 循环

> `for...of`循环可以自动遍历 Generator 函数运行时生成的`Iterator`对象，且此时不再需要调用`next`方法。`for...of` 中定义的变量就是 `yield` 的返回值。

```javascript
function* foo() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
}

for (let v of foo()) {
  console.log(v);
}
// 1 2 3 4 5
```

上面代码使用`for...of`循环，依次显示 5 个`yield`表达式的值。这里需要注意，一旦`next`方法的返回对象的`done`属性为`true`，`for...of`循环就会中止，且不包含该返回对象，所以上面代码的`return`语句返回的`6`，不包括在`for...of`循环之中。

## `yield` 表达式

如果在 `Generator` 函数内部，调用另一个 `Generator` 函数。需要在前者的函数体内部，自己手动完成遍历。

```javascript
function* foo() {
  yield 'a';
  yield 'b';
}

function* bar() {
  yield 'x';
  // 手动遍历 foo()
  for (let i of foo()) {
    console.log(i);
  }
  yield 'y';
}

for (let v of bar()){
  console.log(v);
}
// x
// a
// b
// y
```

ES6 提供了`yield*`表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。

```javascript
function* bar() {
  yield 'x';
  yield* foo();
  yield 'y';
}

// 等同于
function* bar() {
  yield 'x';
  yield 'a';
  yield 'b';
  yield 'y';
}

// 等同于
function* bar() {
  yield 'x';
  for (let v of foo()) {
    yield v;
  }
  yield 'y';
}

for (let v of bar()){
  console.log(v);
}
// "x"
// "a"
// "b"
// "y"
```

## 对象属性时 `Generator` 函数

如果一个对象的属性是 Generator 函数，可以简写成下面的形式。

```javascript
let obj = {
  * myGeneratorMethod() {
    ···
  }
};
```

上面代码中，`myGeneratorMethod`属性前面有一个星号，表示这个属性是一个 Generator 函数。

它的完整形式如下，与上面的写法是等价的。

```javascript
let obj = {
  myGeneratorMethod: function* () {
    // ···
  }
};
```

## `Generator` 函数中的 `this`

> 具体见：[Generator 函数的this](https://es6.ruanyifeng.com/#docs/generator)


1. `Generator` 函数总是返回一个遍历器，ES6 规定这个遍历器是 `Generator` 函数的实例，也继承了 `Generator` 函数的`prototype`对象上的方法。

2. Generator 函数也不能跟`new`命令一起用，会报错。

   

   ```js
   function* F() {
     yield this.x = 2;
     yield this.y = 3;
   }
   
   new F()
   // TypeError: F is not a constructor
   ```

   > 上面代码中，`new`命令跟构造函数`F`一起使用，结果报错，因为`F`不是构造函数。


## Generator状态机

Generator 是实现状态机的最佳结构。比如，下面的`clock`函数就是一个状态机。

```javascript
var ticking = true;
var clock = function() {
  if (ticking)
    console.log('Tick!');
  else
    console.log('Tock!');
  ticking = !ticking;
}
```

上面代码的`clock`函数一共有两种状态（`Tick`和`Tock`），每运行一次，就改变一次状态。这个函数如果用 Generator 实现，就是下面这样。

```javascript
var clock = function* () {
  while (true) {
    console.log('Tick!');
    yield;
    console.log('Tock!');
    yield;
  }
};
```

上面的 Generator 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变量`ticking`，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。

## 应用

Generator 函数的常规应用主要分为下边的四个场景

（1）[异步操作的同步化表达 §](https://es6.ruanyifeng.com/#docs/generator#（1）异步操作的同步化表达) [⇧](https://es6.ruanyifeng.com/#docs/generator)

（2）[控制流管理 §](https://es6.ruanyifeng.com/#docs/generator#（2）控制流管理) [⇧](https://es6.ruanyifeng.com/#docs/generator)

（3）[部署 Iterator 接口 §](https://es6.ruanyifeng.com/#docs/generator#（3）部署-Iterator-接口) [⇧](https://es6.ruanyifeng.com/#docs/generator)

（4）[作为数据结构 §](https://es6.ruanyifeng.com/#docs/generator#（4）作为数据结构) [⇧](https://es6.ruanyifeng.com/#docs/generator)



# `Promise`

> 涉及面试题：Promise 的特点是什么，分别有什么优缺点？什么是 Promise 链？Promise 构造函数执行和 then 函数执行有什么区别？

1. Promise 的特点
   - 有 `pending, resolved, rejected` 三种状态，从一种状态变为另一种状态之后就不能再改变。
   - 当我们在构造 `Promise` 的时候，构造函数内部的代码是立即执行的
2. `Promise` 实现了链式调用，每次调用 `then` 方法之后都会返回一个全新的 `Promise`，如果你在 `then` 中 使用了 `return`，那么 `return` 的值会被 `Promise.resolve()` 包装。
3. Promise 的**缺点**是无法被取消。错误需要通过回调函数捕获。



# `async & await`

> 涉及面试题：async 及 await 的特点，它们的优点和缺点分别是什么？await 原理是什么？

