### 怎么居中一个元素

1. 居中有水平居中，垂直居中

2. 实现水平居中

   1. 行内元素可以有text-align:center就可以
   2. 块级元素用margin：0 auto 或者 flex + justify-content: center来实现

3. 实现垂直居中

   flex + align-items, absolute + transform

### JS是怎么实现继承的



### 对原型和原型链的理解

- 原型设计的目的是为了给构造函数添加继承功能，每一个构造函数都有一个原型对象，并且可以手动指定。
- 构造函数的实例持有一个指向原型对象的引用。

### instanceof 的原理

instanceof的原理就是判断左边对象的原型链上是否存在又边对象的原型，自定义实现，围绕这一点就可以了。

```js
function customerInstanceof(left, right) {
    let leftPrototype = left.__proto__;
    const rightPrototype = right.prototype;
    while(true) {
        if (!leftPrototype) {
            return false;
        }
        if (leftPrototype === rightPrototype) {
            return true;
        }
        
        leftPrototype = leftPrototype.__protot__
    }
}
```



### new 操作符的工作流程

```js
function customerNew() {
    const obj = new Object;  // 1、创建新的对象
    const Constructor = [].shift.call(arguments);
	obj.__proto__ = Constructor.prototype; // 2、设置新对象的原型为构造函数的原型
    const result = Constructor.apply(obj, arguments); // 执行构造函数，获取构造函数返回结果
    return result instanceof Object ? result : obj;
}
```



### Object.create 和 new 操作符的区别

- [Object.create详解](https://juejin.im/post/6844903589815517192)

- [{}、new Object()和Object.create()的区别](https://juejin.im/post/6845166891154178061)

- 他们的作用都是创建一个新的对象

### 浏览器存储

- cookie, localStorage, sessionStorage, indexDB

![浏览器存储四种方法](http://jimilee.tech/assets/img/4.d4f3ac84.png)

- serviceWorker

  `Service Worker`是运行在浏览器背后的独立进程，一般可以用来实现缓存功能，实现`Service Worker`的话，必须使用https传输协议，一个实现`Service Worker`缓存`js`文件可以如下写

  ```js
  if('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./1.js').then(success => {
      console.log('注册成功');
    }).catch(error => {
      console.log('注册失败');
    })
  }
  ```

### 缓存机制

**缓存位置**

> 缓存在不同的位置，它的优先级是不同的，缓存按优先级可以划分为：
>
> 1. Service Worker可以让我们自由控制应该缓存哪些文件(PWA实现的重要手段)
> 2. Memory Cache(内存缓存)内存缓存读取效率高，但一旦我们关闭了浏览器，内存缓存也就没有了。
> 3. Disk Cache(硬盘缓存)与内存缓存相比，硬盘缓存具有量大以及时效的两大优点。
> 4. Push Cache当前三者缓存都没有命中时，才会读取Push Cache中的缓存信息，但此种方式的缓存信息时间较短，只在会话`Session`中存在，一旦会话结束也就释放了。
> 5. 当以上缓存都没有命中时，才会发起请求。

**缓存策略**（面试的时候回答这个就可以了）

> 通常来说，浏览器缓存策略分为两种：**强缓存**和**协商缓存**，缓存策略可通过HTTP Header来实现。

见：https://github.com/songning0605/blog/issues/39

### webpack常用插件

HTTP和HTTPS的理解

TCP和UDP的理解，两者的区别

### 跨域解决方案，纯HTML5跨域解决方案

1. 传统方案

   - JSONP

   - 跨域资源共享（CORS）

   - 中间代理（nginx, Node中间件）

2. 不常用的方案

   - websocket 实现跨域。

   - postMessage。

     ```
     postMessage('消息', origin)
     ```

   - 主子域名的时候可以利用 document.domain 设置域名都为子域名。

3. 网上好文章：https://segmentfault.com/a/1190000011145364

### React中diff算法是怎么实现的

React中有一个预设前提：

1. 只会对同级节点进行diff，如果一个DOM节点在更新前后跨层级移动了，不会被复用。
2. 元素类型不同认为是不一样的。
3. 可以指定key来显示的指定一个节点是否可以复用。

React和Vue的区别

Vue的生命周期

React生态相关