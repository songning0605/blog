<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>你真的掌握变量和类型了吗（一）数据类型 | 前端进阶</title>
    <meta name="generator" content="VuePress 1.5.3">
    
    <meta name="description" content="系统性学习，打造完善的知识体系">
    <link rel="preload" href="/blog/assets/css/0.styles.5dc057b1.css" as="style"><link rel="preload" href="/blog/assets/js/app.d7b4ca64.js" as="script"><link rel="preload" href="/blog/assets/js/2.d2cb7039.js" as="script"><link rel="preload" href="/blog/assets/js/6.46556db1.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.b6d45109.js"><link rel="prefetch" href="/blog/assets/js/11.02c66630.js"><link rel="prefetch" href="/blog/assets/js/12.569c81c8.js"><link rel="prefetch" href="/blog/assets/js/13.2933a416.js"><link rel="prefetch" href="/blog/assets/js/14.e8b9a8eb.js"><link rel="prefetch" href="/blog/assets/js/15.cc49f41e.js"><link rel="prefetch" href="/blog/assets/js/16.fcf94bc8.js"><link rel="prefetch" href="/blog/assets/js/17.212491a7.js"><link rel="prefetch" href="/blog/assets/js/18.aba42cee.js"><link rel="prefetch" href="/blog/assets/js/19.7ca76503.js"><link rel="prefetch" href="/blog/assets/js/20.ef709027.js"><link rel="prefetch" href="/blog/assets/js/21.6dec212e.js"><link rel="prefetch" href="/blog/assets/js/22.2175430e.js"><link rel="prefetch" href="/blog/assets/js/23.72b7e27d.js"><link rel="prefetch" href="/blog/assets/js/24.1d369bec.js"><link rel="prefetch" href="/blog/assets/js/25.4a81ae13.js"><link rel="prefetch" href="/blog/assets/js/26.c516e806.js"><link rel="prefetch" href="/blog/assets/js/27.52b8ed02.js"><link rel="prefetch" href="/blog/assets/js/28.7200da10.js"><link rel="prefetch" href="/blog/assets/js/29.317911aa.js"><link rel="prefetch" href="/blog/assets/js/3.47a74f5f.js"><link rel="prefetch" href="/blog/assets/js/30.a92a3e89.js"><link rel="prefetch" href="/blog/assets/js/31.633db90e.js"><link rel="prefetch" href="/blog/assets/js/32.af4b30d4.js"><link rel="prefetch" href="/blog/assets/js/33.1a6245dc.js"><link rel="prefetch" href="/blog/assets/js/34.73a314bb.js"><link rel="prefetch" href="/blog/assets/js/35.67a47972.js"><link rel="prefetch" href="/blog/assets/js/36.b747b287.js"><link rel="prefetch" href="/blog/assets/js/37.c648cace.js"><link rel="prefetch" href="/blog/assets/js/38.30a84d00.js"><link rel="prefetch" href="/blog/assets/js/39.b63578f8.js"><link rel="prefetch" href="/blog/assets/js/4.3b6a7e49.js"><link rel="prefetch" href="/blog/assets/js/40.3a6f8db1.js"><link rel="prefetch" href="/blog/assets/js/41.9a72472f.js"><link rel="prefetch" href="/blog/assets/js/42.e28f36bb.js"><link rel="prefetch" href="/blog/assets/js/43.d9d88890.js"><link rel="prefetch" href="/blog/assets/js/44.424aa53b.js"><link rel="prefetch" href="/blog/assets/js/45.0556d798.js"><link rel="prefetch" href="/blog/assets/js/46.92a18e35.js"><link rel="prefetch" href="/blog/assets/js/47.56e9f1e4.js"><link rel="prefetch" href="/blog/assets/js/48.4869689c.js"><link rel="prefetch" href="/blog/assets/js/49.8b4ade4a.js"><link rel="prefetch" href="/blog/assets/js/5.bc6e1aa4.js"><link rel="prefetch" href="/blog/assets/js/7.63a358f8.js"><link rel="prefetch" href="/blog/assets/js/8.088f79f0.js"><link rel="prefetch" href="/blog/assets/js/9.6c4360fc.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.5dc057b1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/favicon.png" alt="前端进阶" class="logo"> <span class="site-name can-hide">前端进阶</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/article/" class="nav-link router-link-active">
  文章目录
</a></div><div class="nav-item"><a href="http://www.conardli.top" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/ConardLi" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/article/" class="nav-link router-link-active">
  文章目录
</a></div><div class="nav-item"><a href="http://www.conardli.top" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/ConardLi" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/article/" aria-current="page" class="sidebar-link">文章目录</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JS进阶</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html" class="active sidebar-link">你真的掌握变量和类型了吗（一）数据类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#导读" class="sidebar-link">导读</a></li><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#一、javascript数据类型" class="sidebar-link">一、JavaScript数据类型</a></li><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#二、为什么区分原始类型和对象类型" class="sidebar-link">二、为什么区分原始类型和对象类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#_2-1-不可变性" class="sidebar-link">2.1 不可变性</a></li><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#_2-2-引用类型" class="sidebar-link">2.2 引用类型</a></li><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#_2-3-复制" class="sidebar-link">2.3 复制</a></li><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#_2-4-比较" class="sidebar-link">2.4 比较</a></li><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#_2-5-值传递和引用传递" class="sidebar-link">2.5 值传递和引用传递</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#三、分不清的null和undefined" class="sidebar-link">三、分不清的null和undefined</a></li><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#四、不太熟的symbol类型" class="sidebar-link">四、不太熟的Symbol类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#_4-1-symbol的特性" class="sidebar-link">4.1 Symbol的特性</a></li><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#_4-2-symbol的应用场景" class="sidebar-link">4.2 Symbol的应用场景</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#五、不老实的number类型" class="sidebar-link">五、不老实的Number类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#_5-1-精度丢失" class="sidebar-link">5.1 精度丢失</a></li><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#_5-2-对结果的分析-更多的问题" class="sidebar-link">5.2 对结果的分析—更多的问题</a></li><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#_5-3-js对二进制小数的存储方式" class="sidebar-link">5.3 js对二进制小数的存储方式</a></li><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#_5-4-ieee-754" class="sidebar-link">5.4 IEEE 754</a></li><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#_5-5-js中的tostring-2" class="sidebar-link">5.5 js中的toString(2)</a></li><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#_5-6-javascript能表示的最大数字" class="sidebar-link">5.6 JavaScript能表示的最大数字</a></li><li class="sidebar-sub-header"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（一）数据类型.html#_5-7-最大安全数字" class="sidebar-link">5.7 最大安全数字</a></li></ul></li></ul></li><li><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（二）类型转换.html" class="sidebar-link">你真的掌握变量和类型了吗（二）类型转换</a></li><li><a href="/blog/article/JS进阶/如何写出一个惊艳面试官的深拷贝.html" class="sidebar-link">如何写出一个惊艳面试官的深拷贝</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React深入系列</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>多端开发</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器和网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器策略</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端安全</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端工程化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>效果</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>博客搭建</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>综合</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>技术圈</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="导读"><a href="#导读" class="header-anchor">#</a> 导读</h2> <p>变量和类型是学习<code>JavaScript</code>最先接触到的东西，但是往往看起来最简单的东西往往还隐藏着很多你不了解、或者容易犯错的知识，比如下面几个问题：</p> <ul><li><code>JavaScript</code>中的变量在内存中的具体存储形式是什么？</li> <li><code>0.1+0.2</code>为什么不等于<code>0.3</code>?发生小数计算错误的具体原因是什么？</li> <li><code>Symbol</code>的特点，以及实际应用场景是什么？</li> <li><code>[] == ![]</code>、<code>[undefined] == false</code>为什么等于<code>true</code>?代码中何时会发生隐式类型转换？转换的规则是什么？</li> <li>如何精确的判断变量的类型？</li></ul> <p>如果你还不能很好的解答上面的问题，那说明你还没有完全掌握这部分的知识，那么请好好阅读下面的文章吧。</p> <p>本文从底层原理到实际应用详细介绍了<code>JavaScript</code>中的变量和类型相关知识。</p> <h2 id="一、javascript数据类型"><a href="#一、javascript数据类型" class="header-anchor">#</a> 一、JavaScript数据类型</h2> <p><a href="http://www.ecma-international.org/ecma-262/9.0/index.html" target="_blank" rel="noopener noreferrer">ECMAScript标准<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>规定了<code>7</code>种数据类型，其把这<code>7</code>种数据类型又分为两种：原始类型和对象类型。</p> <p><strong>原始类型</strong></p> <ul><li><code>Null</code>：只包含一个值：<code>null</code></li> <li><code>Undefined</code>：只包含一个值：<code>undefined</code></li> <li><code>Boolean</code>：包含两个值：<code>true</code>和<code>false</code></li> <li><code>Number</code>：整数或浮点数，还有一些特殊值（<code>-Infinity</code>、<code>+Infinity</code>、<code>NaN</code>）</li> <li><code>String</code>：一串表示文本值的字符序列</li> <li><code>Symbol</code>：一种实例是唯一且不可改变的数据类型</li></ul> <p>(在<code>es10</code>中加入了第七种原始类型<code>BigInt</code>，现已被最新<code>Chrome</code>支持)</p> <p><strong>对象类型</strong></p> <ul><li><code>Object</code>：自己分一类丝毫不过分，除了常用的<code>Object</code>，<code>Array</code>、<code>Function</code>等都属于特殊的对象</li></ul> <h2 id="二、为什么区分原始类型和对象类型"><a href="#二、为什么区分原始类型和对象类型" class="header-anchor">#</a> 二、为什么区分原始类型和对象类型</h2> <h3 id="_2-1-不可变性"><a href="#_2-1-不可变性" class="header-anchor">#</a> 2.1 不可变性</h3> <p>上面所提到的原始类型，在<code>ECMAScript</code>标准中，它们被定义为<code>primitive values</code>，即原始值，代表值本身是不可被改变的。</p> <p>以字符串为例，我们在调用操作字符串的方法时，没有任何方法是可以直接改变字符串的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'ConardLi'</span><span class="token punctuation">;</span>
str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
str<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
str<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ConardLi</span>
</code></pre></div><p>在上面的代码中我们对<code>str</code>调用了几个方法，无一例外，这些方法都在原字符串的基础上产生了一个新字符串，而非直接去改变<code>str</code>，这就印证了字符串的不可变性。</p> <p>那么，当我们继续调用下面的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>str <span class="token operator">+=</span> <span class="token string">'6'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ConardLi6</span>
</code></pre></div><p>你会发现，<code>str</code>的值被改变了，这不就打脸了字符串的不可变性么？其实不然，我们从内存上来理解：</p> <p>在<code>JavaScript</code>中，每一个变量在内存中都需要一个空间来存储。</p> <p>内存空间又被分为两种，栈内存与堆内存。</p> <p>栈内存：</p> <ul><li>存储的值大小固定</li> <li>空间较小</li> <li>可以直接操作其保存的变量，运行效率高</li> <li>由系统自动分配存储空间</li></ul> <p><code>JavaScript</code>中的原始类型的值被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间。</p> <p><img src="http://www.conardli.top/img/bl/bl_1_stack.png" alt=""></p> <p>由于栈中的内存空间的大小是固定的，那么注定了存储在栈中的变量就是不可变的。</p> <p>在上面的代码中，我们执行了<code>str += '6'</code>的操作，实际上是在栈中又开辟了一块内存空间用于存储<code>'ConardLi6'</code>，然后将变量<code>str</code>指向这块空间，所以这并不违背<code>不可变性的</code>特点。</p> <p><img src="http://www.conardli.top/img/bl/bl_2_stack.png" alt=""></p> <h3 id="_2-2-引用类型"><a href="#_2-2-引用类型" class="header-anchor">#</a> 2.2 引用类型</h3> <p>堆内存：</p> <ul><li>存储的值大小不定，可动态调整</li> <li>空间较大，运行效率低</li> <li>无法直接操作其内部存储，使用引用地址读取</li> <li>通过代码进行分配空间</li></ul> <p>相对于上面具有不可变性的原始类型，我习惯把对象称为引用类型，引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">&quot;ConardLi&quot;</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>age<span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> <span class="token function-variable function">obj3</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> obj4 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
</code></pre></div><p><img src="http://www.conardli.top/img/bl/bl_3_heap.png" alt=""></p> <blockquote><p>由于内存是有限的，这些变量不可能一直在内存中占用资源，这里推荐下这篇文章<a href="https://juejin.im/post/5cb33660e51d456e811d2687" target="_blank" rel="noopener noreferrer">JavaScript中的垃圾回收和内存泄漏<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这里告诉你<code>JavaScript</code>是如何进行垃圾回收以及可能会发生内存泄漏的一些场景。</p></blockquote> <p>当然，引用类型就不再具有<code>不可变性</code>了，我们可以轻易的改变它们：</p> <div class="language-js extra-class"><pre class="language-js"><code>obj1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;ConardLi6&quot;</span><span class="token punctuation">;</span>
obj2<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">19</span><span class="token punctuation">;</span>
obj4<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//{name:&quot;ConardLi6&quot;}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {age:19}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// []</span>
</code></pre></div><p>以数组为例，它的很多方法都可以改变它自身。</p> <ul><li><code>pop()</code> 删除数组最后一个元素，如果数组为空，则不改变数组，返回undefined，改变原数组，返回被删除的元素</li> <li><code>push()</code>向数组末尾添加一个或多个元素，改变原数组，返回新数组的长度</li> <li><code>shift()</code>把数组的第一个元素删除，若空数组，不进行任何操作，返回undefined,改变原数组，返回第一个元素的值</li> <li><code>unshift()</code>向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度</li> <li><code>reverse()</code>颠倒数组中元素的顺序，改变原数组，返回该数组</li> <li><code>sort()</code>对数组元素进行排序，改变原数组，返回该数组</li> <li><code>splice()</code>从数组中添加/删除项目，改变原数组，返回被删除的元素</li></ul> <p>下面我们通过几个操作来对比一下原始类型和引用类型的区别：</p> <h3 id="_2-3-复制"><a href="#_2-3-复制" class="header-anchor">#</a> 2.3 复制</h3> <p>当我们把一个变量的值复制到另一个变量上时，原始类型和引用类型的表现是不一样的，先来看看原始类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'ConardLi'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> name2 <span class="token operator">=</span> name<span class="token punctuation">;</span>
name2 <span class="token operator">=</span> <span class="token string">'code秘密花园'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ConardLi;</span>
</code></pre></div><p><img src="http://www.conardli.top/img/bl/bl_4_copy.png" alt=""></p> <p>内存中有一个变量<code>name</code>，值为<code>ConardLi</code>。我们从变量<code>name</code>复制出一个变量<code>name2</code>，此时在内存中创建了一个块新的空间用于存储<code>ConardLi</code>，虽然两者值是相同的，但是两者指向的内存空间完全不同，这两个变量参与任何操作都互不影响。</p> <p>复制一个引用类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">'ConardLi'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj2 <span class="token operator">=</span> obj<span class="token punctuation">;</span>
obj2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'code秘密花园'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// code秘密花园</span>
</code></pre></div><p><img src="http://www.conardli.top/img/bl/bl_5_copy.png" alt=""></p> <p>当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，所以复制出来的<code>obj2</code>实际上和<code>obj</code>指向的堆中同一个对象。因此，我们改变其中任何一个变量的值，另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因。</p> <h3 id="_2-4-比较"><a href="#_2-4-比较" class="header-anchor">#</a> 2.4 比较</h3> <p>当我们在对两个变量进行比较时，不同类型的变量的表现是不同的：</p> <p><img src="http://www.conardli.top/img/bl/bl_6_compare.png" alt=""></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'ConardLi'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> name2 <span class="token operator">=</span> <span class="token string">'ConardLi'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name <span class="token operator">===</span> name2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">'ConardLi'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">'ConardLi'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj <span class="token operator">===</span> obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><p>对于原始类型，比较时会直接比较它们的值，如果值相等，即返回<code>true</code>。</p> <p>对于引用类型，比较时会比较它们的引用地址，虽然两个变量在堆中存储的对象具有的属性值都是相等的，但是它们被存储在了不同的存储空间，因此比较值为<code>false</code>。</p> <h3 id="_2-5-值传递和引用传递"><a href="#_2-5-值传递和引用传递" class="header-anchor">#</a> 2.5 值传递和引用传递</h3> <p>借助下面的例子，我们先来看一看什么是值传递，什么是引用传递：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">'ConardLi'</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">changeValue</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  name <span class="token operator">=</span> <span class="token string">'code秘密花园'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">changeValue</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>执行上面的代码，如果最终打印出来的<code>name</code>是<code>'ConardLi'</code>，没有改变，说明函数参数传递的是变量的值，即值传递。如果最终打印的是<code>'code秘密花园'</code>，函数内部的操作可以改变传入的变量，那么说明函数参数传递的是引用，即引用传递。</p> <p>很明显，上面的执行结果是<code>'ConardLi'</code>，即函数参数仅仅是被传入变量复制给了的一个局部变量，改变这个局部变量不会对外部变量产生影响。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">'ConardLi'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">changeValue</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'code秘密花园'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">changeValue</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// code秘密花园</span>
</code></pre></div><p>上面的代码可能让你产生疑惑，是不是参数是引用类型就是引用传递呢？</p> <p>首先明确一点，<code>ECMAScript</code>中所有的函数的参数都是按值传递的。</p> <p>同样的，当函数参数是引用类型时，我们同样将参数复制了一个副本到局部变量，只不过复制的这个副本是指向堆内存中的地址而已，我们在函数内部对对象的属性进行操作，实际上和外部变量指向堆内存中的值相同，但是这并不代表着引用传递，下面我们再按一个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">changeValue</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'ConardLi'</span><span class="token punctuation">;</span>
  obj <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">'code秘密花园'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">changeValue</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ConardLi</span>
</code></pre></div><p>可见，函数参数传递的并不是变量的<code>引用</code>，而是变量拷贝的副本，当变量是原始类型时，这个副本就是值本身，当变量是引用类型时，这个副本是指向堆内存的地址。所以，再次记住：</p> <blockquote><p><code>ECMAScript</code>中所有的函数的参数都是按值传递的。</p></blockquote> <h2 id="三、分不清的null和undefined"><a href="#三、分不清的null和undefined" class="header-anchor">#</a> 三、分不清的null和undefined</h2> <p><img src="http://www.conardli.top/img/bl/bl_7_null.png" alt=""></p> <p>在原始类型中，有两个类型<code>Null</code>和<code>Undefined</code>，他们都有且仅有一个值，<code>null</code>和<code>undefined</code>，并且他们都代表无和空，我一般这样区分它们：</p> <p><strong>null</strong></p> <p>表示被赋值过的对象，刻意把一个对象赋值为<code>null</code>，故意表示其为空，不应有值。</p> <p>所以对象的某个属性值为<code>null</code>是正常的，<code>null</code>转换为数值时值为<code>0</code>。</p> <p><strong>undefined</strong></p> <p>表示“缺少值”，即此处应有一个值，但还没有定义，</p> <p>如果一个对象的某个属性值为<code>undefined</code>，这是不正常的，如<code>obj.name=undefined</code>，我们不应该这样写，应该直接<code>delete obj.name</code>。</p> <p><code>undefined</code>转为数值时为<code>NaN</code>(非数字值的特殊值)</p> <p><code>JavaScript</code>是一门动态类型语言，成员除了表示存在的空值外，还有可能根本就不存在（因为存不存在只在运行期才知道），这就是<code>undefined</code>的意义所在。对于<code>JAVA</code>这种强类型语言，如果有<code>&quot;undefined&quot;</code>这种情况，就会直接编译失败，所以在它不需要一个这样的类型。</p> <h2 id="四、不太熟的symbol类型"><a href="#四、不太熟的symbol类型" class="header-anchor">#</a> 四、不太熟的Symbol类型</h2> <p><code>Symbol</code>类型是<code>ES6</code>中新加入的一种原始类型。</p> <blockquote><p>每个从Symbol()返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。</p></blockquote> <p>下面来看看<code>Symbol</code>类型具有哪些特性。</p> <h3 id="_4-1-symbol的特性"><a href="#_4-1-symbol的特性" class="header-anchor">#</a> 4.1 Symbol的特性</h3> <p><strong>1.独一无二</strong></p> <p>直接使用<code>Symbol()</code>创建新的<code>symbol</code>变量，可选用一个字符串用于描述。当参数为对象时，将调用对象的<code>toString()</code>方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> sym1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Symbol() </span>
<span class="token keyword">var</span> sym2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'ConardLi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Symbol(ConardLi)</span>
<span class="token keyword">var</span> sym3 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'ConardLi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Symbol(ConardLi)</span>
<span class="token keyword">var</span> sym4 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">'ConardLi'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Symbol([object Object])</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sym2 <span class="token operator">===</span> sym3<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// false</span>
</code></pre></div><p>我们用两个相同的字符串创建两个<code>Symbol</code>变量，它们是不相等的，可见每个<code>Symbol</code>变量都是独一无二的。</p> <p>如果我们想创造两个相等的<code>Symbol</code>变量，可以使用<code>Symbol.for(key)</code>。</p> <blockquote><p>使用给定的key搜索现有的symbol，如果找到则返回该symbol。否则将使用给定的key在全局symbol注册表中创建一个新的symbol。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> sym1 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'ConardLi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> sym2 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'ConardLi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sym1 <span class="token operator">===</span> sym2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p><strong>2.原始类型</strong></p> <p>注意是使用<code>Symbol()</code>函数创建<code>symbol</code>变量，并非使用构造函数，使用<code>new</code>操作符会直接报错。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught TypeError: Symbol is not a constructor</span>
</code></pre></div><p>我们可以使用<code>typeof</code>运算符判断一个<code>Symbol</code>类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'symbol'</span>
<span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'ConardLi'</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'symbol'</span>
</code></pre></div><p><strong>3.不可枚举</strong></p> <p>当使用<code>Symbol</code>作为对象属性时，可以保证对象不会出现重名属性，调用<code>for...in</code>不能将其枚举出来，另外调用<code>Object.getOwnPropertyNames、Object.keys()</code>也不能获取<code>Symbol</code>属性。</p> <blockquote><p>可以调用Object.getOwnPropertySymbols()用于专门获取Symbol属性。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span><span class="token string">'ConardLi'</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'name2'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">:</span><span class="token string">'code秘密花园'</span>
<span class="token punctuation">}</span>
Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [&quot;name&quot;]</span>
Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [&quot;name&quot;]</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// name</span>
<span class="token punctuation">}</span>
Object<span class="token punctuation">.</span><span class="token function">getOwnPropertySymbols</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token comment">// [Symbol(name)]</span>
</code></pre></div><h3 id="_4-2-symbol的应用场景"><a href="#_4-2-symbol的应用场景" class="header-anchor">#</a> 4.2 Symbol的应用场景</h3> <p>下面是几个<code>Symbol</code>在程序中的应用场景。</p> <p><strong>应用一：防止XSS</strong></p> <p>在<code>React</code>的<code>ReactElement</code>对象中，有一个<code>$$typeof</code>属性，它是一个<code>Symbol</code>类型的变量：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token constant">REACT_ELEMENT_TYPE</span> <span class="token operator">=</span>
  <span class="token punctuation">(</span><span class="token keyword">typeof</span> Symbol <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">&amp;&amp;</span> Symbol<span class="token punctuation">.</span>for <span class="token operator">&amp;&amp;</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'react.element'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span>
  <span class="token number">0xeac7</span><span class="token punctuation">;</span>
</code></pre></div><p><code>ReactElement.isValidElement</code>函数用来判断一个React组件是否是有效的，下面是它的具体实现。</p> <div class="language-js extra-class"><pre class="language-js"><code>ReactElement<span class="token punctuation">.</span><span class="token function-variable function">isValidElement</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">typeof</span> object <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> object <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> object<span class="token punctuation">.</span>$$<span class="token keyword">typeof</span> <span class="token operator">===</span> <span class="token constant">REACT_ELEMENT_TYPE</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>可见<code>React</code>渲染时会把没有<code>$$typeof</code>标识，以及规则校验不通过的组件过滤掉。</p> <p>如果你的服务器有一个漏洞，允许用户存储任意<code>JSON</code>对象， 而客户端代码需要一个字符串，这可能会成为一个问题：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// JSON</span>
<span class="token keyword">let</span> expectedTextButGotJSON <span class="token operator">=</span> <span class="token punctuation">{</span>
  type<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    dangerouslySetInnerHTML<span class="token operator">:</span> <span class="token punctuation">{</span>
      __html<span class="token operator">:</span> <span class="token string">'/* put your exploit here */'</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> message <span class="token operator">=</span> <span class="token punctuation">{</span> text<span class="token operator">:</span> expectedTextButGotJSON <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>
  <span class="token punctuation">{</span>message<span class="token punctuation">.</span>text<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
</code></pre></div><p>而<code>JSON</code>中不能存储<code>Symbol</code>类型的变量，这就是防止<code>XSS</code>的一种手段。</p> <p><strong>应用二：私有属性</strong></p> <p>借助<code>Symbol</code>类型的不可枚举，我们可以在类中模拟私有属性，控制变量读写：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> privateField <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">myClass</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">[</span>privateField<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'ConardLi'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">getField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span>privateField<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">setField</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">[</span>privateField<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>应用三：防止属性污染</strong></p> <p>在某些情况下，我们可能要为对象添加一个属性，此时就有可能造成属性覆盖，用<code>Symbol</code>作为对象属性可以保证永远不会出现同名属性。</p> <p>例如下面的场景，我们模拟实现一个<code>call</code>方法：</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// 用于防止 Function.prototype.myCall() 直接调用</span>
      <span class="token punctuation">}</span>
      context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>
      <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> result <span class="token operator">=</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">delete</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>我们需要在某个对象上临时调用一个方法，又不能造成属性污染，<code>Symbol</code>是一个很好的选择。</p> <h2 id="五、不老实的number类型"><a href="#五、不老实的number类型" class="header-anchor">#</a> 五、不老实的Number类型</h2> <p>为什么说<code>Number</code>类型不老实呢，相信大家都多多少少的在开发中遇到过小数计算不精确的问题，比如<code>0.1+0.2!==0.3</code>，下面我们来追本溯源，看看为什么会出现这种现象，以及该如何避免。</p> <p>下面是我实现的一个简单的函数，用于判断两个小数进行加法运算是否精确：</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">function</span> <span class="token function">judgeFloat</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span> m</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> binaryN <span class="token operator">=</span> n<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> binaryM <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>n<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">的二进制是    </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>binaryN<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>m<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">的二进制是    </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>binaryM<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> <span class="token constant">MN</span> <span class="token operator">=</span> m <span class="token operator">+</span> n<span class="token punctuation">;</span>
      <span class="token keyword">const</span> accuracyMN <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">+</span> n <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> binaryMN <span class="token operator">=</span> <span class="token constant">MN</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> accuracyBinaryMN <span class="token operator">=</span> accuracyMN<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>n<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">+</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>m<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">的二进制是</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>binaryMN<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>accuracyMN<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">的二进制是    </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>accuracyBinaryMN<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>n<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">+</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>m<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">的二进制再转成十进制是</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">to10</span><span class="token punctuation">(</span>binaryMN<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>accuracyMN<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">的二进制是再转成十进制是</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">to10</span><span class="token punctuation">(</span>accuracyBinaryMN<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>n<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">+</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>m<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">在js中计算是</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token punctuation">(</span><span class="token function">to10</span><span class="token punctuation">(</span>binaryMN<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">to10</span><span class="token punctuation">(</span>accuracyBinaryMN<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">''</span> <span class="token operator">:</span> <span class="token string">'不'</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">准确的</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">function</span> <span class="token function">to10</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> pre <span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> arr <span class="token operator">=</span> n<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        result <span class="token operator">+=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">judgeFloat</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">judgeFloat</span><span class="token punctuation">(</span><span class="token number">0.6</span><span class="token punctuation">,</span> <span class="token number">0.7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/%E4%BA%8C%E8%BF%9B%E5%88%B63.png" alt="image"></p> <h3 id="_5-1-精度丢失"><a href="#_5-1-精度丢失" class="header-anchor">#</a> 5.1 精度丢失</h3> <p>计算机中所有的数据都是以<code>二进制</code>存储的，所以在计算时计算机要把数据先转换成<code>二进制</code>进行计算，然后在把计算结果转换成<code>十进制</code>。</p> <p>由上面的代码不难看出，在计算<code>0.1+0.2</code>时，<code>二进制</code>计算发生了精度丢失，导致再转换成<code>十进制</code>后和预计的结果不符。</p> <h3 id="_5-2-对结果的分析-更多的问题"><a href="#_5-2-对结果的分析-更多的问题" class="header-anchor">#</a> 5.2 对结果的分析—更多的问题</h3> <p><code>0.1</code>和<code>0.2</code>的二进制都是以1100无限循环的小数，下面逐个来看JS帮我们计算所得的结果：</p> <p><strong>0.1的二进制</strong>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0.0001100110011001100110011001100110011001100110011001101</span>
</code></pre></div><p><strong>0.2的二进制</strong>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0.001100110011001100110011001100110011001100110011001101</span>
</code></pre></div><p><strong>理论上讲，由上面的结果相加应该：</strong>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0.0100110011001100110011001100110011001100110011001100111</span>
</code></pre></div><p><strong>实际JS计算得到的0.1+0.2的二进制</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0.0100110011001100110011001100110011001100110011001101</span>
</code></pre></div><p>看到这里你可能会产生更多的问题：</p> <blockquote><p>为什么 js计算出的 0.1的二进制 是这么多位而不是更多位？？？</p></blockquote> <blockquote><p>为什么 js计算的（0.1+0.2）的二进制和我们自己计算的（0.1+0.2）的二进制结果不一样呢？？？</p></blockquote> <blockquote><p>为什么 0.1的二进制 + 0.2的二进制 != 0.3的二进制？？？</p></blockquote> <h3 id="_5-3-js对二进制小数的存储方式"><a href="#_5-3-js对二进制小数的存储方式" class="header-anchor">#</a> 5.3 js对二进制小数的存储方式</h3> <p>小数的<code>二进制</code>大多数都是无限循环的，<code>JavaScript</code>是怎么来存储他们的呢？</p> <p>在<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-4.3.19" target="_blank" rel="noopener noreferrer">ECMAScript®语言规范<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中可以看到，<code>ECMAScript</code>中的<code>Number</code>类型遵循<code>IEEE 754</code>标准。使用64位固定长度来表示。</p> <p>事实上有很多语言的数字类型都遵循这个标准，例如<code>JAVA</code>,所以很多语言同样有着上面同样的问题。</p> <p>所以下次遇到这种问题不要上来就喷<code>JavaScript</code>...</p> <p>有兴趣可以看看下这个网站<a href="http://0.30000000000000004.com/" target="_blank" rel="noopener noreferrer">http://0.30000000000000004.com/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，是的，你没看错，就是<a href="http://0.30000000000000004.com/" target="_blank" rel="noopener noreferrer">http://0.30000000000000004.com/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>！！！</p> <h3 id="_5-4-ieee-754"><a href="#_5-4-ieee-754" class="header-anchor">#</a> 5.4 IEEE 754</h3> <p><code>IEEE754</code>标准包含一组实数的二进制表示法。它有三部分组成：</p> <ul><li><p>符号位</p></li> <li><p>指数位</p></li> <li><p>尾数位</p></li></ul> <p>三种精度的浮点数各个部分位数如下：</p> <p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/%E4%BA%8C%E8%BF%9B%E5%88%B61.png" alt="image"></p> <p><code>JavaScript</code>使用的是64位双精度浮点数编码，所以它的<code>符号位</code>占<code>1</code>位，指数位占<code>11</code>位，尾数位占<code>52</code>位。</p> <p>下面我们在理解下什么是<code>符号位</code>、<code>指数位</code>、<code>尾数位</code>，以<code>0.1</code>为例：</p> <p>它的二进制为：<code>0.0001100110011001100...</code></p> <p>为了节省存储空间，在计算机中它是以科学计数法表示的，也就是</p> <p><code>1.100110011001100...</code> X 2<sup>-4</sup></p> <p>如果这里不好理解可以想一下十进制的数：</p> <p><code>1100</code>的科学计数法为<code>11</code> X 10<sup>2</sup></p> <p>所以：</p> <p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/%E4%BA%8C%E8%BF%9B%E5%88%B62.png" alt="image"></p> <p><code>符号位</code>就是标识正负的，<code>1</code>表示<code>负</code>，<code>0</code>表示<code>正</code>；</p> <p><code>指数位</code>存储科学计数法的指数；</p> <p><code>尾数位</code>存储科学计数法后的有效数字；</p> <p>所以我们通常看到的二进制，其实是计算机实际存储的尾数位。</p> <h3 id="_5-5-js中的tostring-2"><a href="#_5-5-js中的tostring-2" class="header-anchor">#</a> 5.5 js中的toString(2)</h3> <p>由于尾数位只能存储<code>52</code>个数字，这就能解释<code>toString(2)</code>的执行结果了：</p> <p>如果计算机没有存储空间的限制，那么<code>0.1</code>的<code>二进制</code>应该是：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0.00011001100110011001100110011001100110011001100110011001</span><span class="token operator">...</span>
</code></pre></div><p>科学计数法尾数位</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1.1001100110011001100110011001100110011001100110011001</span><span class="token operator">...</span>
</code></pre></div><p>但是由于限制，有效数字第<code>53</code>位及以后的数字是不能存储的，它遵循，如果是<code>1</code>就向前一位进<code>1</code>，如果是<code>0</code>就舍弃的原则。</p> <p>0.1的二进制科学计数法第53位是1，所以就有了下面的结果：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0.0001100110011001100110011001100110011001100110011001101</span>
</code></pre></div><p><code>0.2</code>有着同样的问题，其实正是由于这样的存储，在这里有了精度丢失，导致了<code>0.1+0.2!=0.3</code>。</p> <p>事实上有着同样精度问题的计算还有很多，我们无法把他们都记下来，所以当程序中有数字计算时，我们最好用工具库来帮助我们解决，下面是两个推荐使用的开源库：</p> <ul><li><a href="https://github.com/nefe/number-precision" target="_blank" rel="noopener noreferrer">number-precision<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/josdejong/mathjs/" target="_blank" rel="noopener noreferrer">mathjs/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="_5-6-javascript能表示的最大数字"><a href="#_5-6-javascript能表示的最大数字" class="header-anchor">#</a> 5.6 JavaScript能表示的最大数字</h3> <p>由与<code>IEEE 754</code>双精度64位规范的限制：</p> <p><code>指数位</code>能表示的最大数字：<code>1023</code>(十进制)</p> <p><code>尾数位</code>能表达的最大数字即尾数位都位<code>1</code>的情况</p> <p>所以JavaScript能表示的最大数字即位</p> <p><code>1.111...</code>X 2<sup>1023</sup> 这个结果转换成十进制是<code>1.7976931348623157e+308</code>,这个结果即为<code>Number.MAX_VALUE</code>。</p> <h3 id="_5-7-最大安全数字"><a href="#_5-7-最大安全数字" class="header-anchor">#</a> 5.7 最大安全数字</h3> <p>JavaScript中<code>Number.MAX_SAFE_INTEGER</code>表示最大安全数字,计算结果是<code>9007199254740991</code>，即在这个数范围内不会出现精度丢失（小数除外）,这个数实际上是<code>1.111...</code>X 2<sup>52</sup>。</p> <p>我们同样可以用一些开源库来处理大整数：</p> <ul><li><a href="https://github.com/justmoon/node-bignum" target="_blank" rel="noopener noreferrer">node-bignum<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/substack/node-bigint" target="_blank" rel="noopener noreferrer">node-bigint<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <p>其实官方也考虑到了这个问题，<code>bigInt</code>类型在<code>es10</code>中被提出，现在<code>Chrome</code>中已经可以使用，使用<code>bigInt</code>可以操作超过最大安全数字的数字。</p> <p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/article/" class="prev router-link-active">
        文章目录
      </a></span> <span class="next"><a href="/blog/article/JS进阶/你真的掌握变量和类型了吗（二）类型转换.html">
        你真的掌握变量和类型了吗（二）类型转换
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.d7b4ca64.js" defer></script><script src="/blog/assets/js/2.d2cb7039.js" defer></script><script src="/blog/assets/js/6.46556db1.js" defer></script>
  </body>
</html>
